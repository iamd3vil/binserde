// Code generated by gandalf(BuildDate: 2021-06-03 22:22:31, Version: 66cecb0 (2021-06-03 22:20:15 +0530)). DO NOT EDIT.
package main

import (
	"encoding/binary"
	"errors"
)

func (s *TestBin) Marshal() []byte {
	dest := make([]byte, s.Size())
	offset := 0
	copy(dest[offset:offset+4], []byte(s.Name))
	offset += 4
	copy(dest[offset:offset+4], []byte(s.NameBytes))
	offset += 4
	binary.BigEndian.PutUint32(dest[offset:offset+4], uint32(s.Age))
	offset += 4
	binary.BigEndian.PutUint64(dest[offset:offset+8], uint64(s.Age2))
	offset += 8
	binary.BigEndian.PutUint16(dest[offset:offset+2], uint16(s.Age3))
	offset += 2
	return dest
}

func (s *TestBin) Size() int {
	ln := 0
	ln += 4
	ln += 4
	ln += 4
	ln += 8
	ln += 2
	return ln
}
func (s *TestBin) Unmarshal(data []byte) error {
	if len(data) < s.Size() {
		return errors.New("error while unmarshalling: data is not enough size")
	}
	offset := 0
	s.Name = string(data[offset : offset+4])
	offset += 4
	s.NameBytes = data[offset : offset+4]
	offset += 4
	s.Age = int32(binary.BigEndian.Uint32(data[offset : offset+4]))
	offset += 4
	s.Age2 = int64(binary.BigEndian.Uint64(data[offset : offset+8]))
	offset += 8
	s.Age3 = int16(binary.BigEndian.Uint16(data[offset : offset+2]))
	offset += 2
	return nil
}
